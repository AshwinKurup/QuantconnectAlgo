from datetime import timedelta 
class OpeningRangeBreakout(QCAlgorithm):
    
    
    def Initialize(self):

    

        self.equities = {}
        
        '''stockList  = ['AMWL', 'AQB', 'ASAN', 'BNTX', 'CCJ', 'DMYD', 'GIK', 'GTEC', 'HCAC', 'IPOB', 'IPV', 'KODK', 'MFGP', 'MP', 'NGA', 'PSTH', 'QELL', 'SAMA', 'SBE', 'SPCE', 'TRNE', 'VGAC', 'VTRS', 'YALA']
        for stockName in stockList:
            self.Debug(stockName)
            self.Debug('roptint')
            self.equities[stockName] = Stock(stockName)'''

        #self.equities = {'AAPL':Stock('AAPL'), 'ATHX':Stock('ATHX'), 'SNAP':Stock('SNAP'), 'FB':Stock('FB'), 'JBL':Stock('JBL'), 'JBL':Stock('JBL'), 'KO':Stock('KO')}
        
        self.equities = {"NIO":Stock('NIO'), "SRNE":Stock('SRNE'), "PLUG":Stock('PLUG'), "NETE":Stock('NETE'), "TSLA":Stock('TSLA'), "CBAT":Stock('CBAT'), "GME":Stock("GME")
        
                        , "SPI":Stock("SPI"), "ABIO":Stock("ABIO"), "SGBX":Stock("SGBX"), "POLA":Stock("POLA"), "AIM":Stock("AIM"), "GNUS":Stock("GNUS")
                        
                        , "ALT": Stock("ALT"), "NCTY":Stock("NCTY"), "FLDM":Stock("FLDM"), "TTNP":Stock("TTNP"), "ACET":Stock("ACET")
                    
                        , "LUB": Stock("LUB"), "NURO":Stock("NURO"), "AMPE":Stock("AMPE"), "PEIX":Stock("PEIX"), "OMI":Stock("OMI")
                        
                        ,"RMTI": Stock("RMTI"), "TATT":Stock("TATT"), "SYPR":Stock("SYPR"), "AAPL":Stock("AAPL"), "SPY":Stock("SPY")
                        
                        , "PPSI": Stock("PPSI"), "CRMD":Stock("CRMD"), "ONTX":Stock("ONTX"), "PLL":Stock("PLL"), "KNOS":Stock("KNOS") 
                        
                        ,"LLLI": Stock("LLLI"), "NWBO":Stock("NWBO"), "HYSR":Stock("HYSR"), "JRJC":Stock("JRJC"), "GAXY":Stock("GAXY")
                        
                        , "BDR":Stock("BDR"), "CUB":Stock("CUB"), "FB":Stock("FB")
                        
                        , "LOGC": Stock("LOGC"), "PENN":Stock("PENN"), "MOV":Stock("MOV"), "CLNY":Stock("CLNY"), "NTN":Stock("NTN") 
                        
                        ,"ALYI": Stock("ALYI"), "CREG":Stock("CREG"), "ATHX":Stock("ATHX"), "ADXS":Stock("ADXS"), "SSP":Stock("SSP")
                        
                        , "CPSH": Stock("CPSH"), "DSGT":Stock("DSGT"), "SOL":Stock("SOL"), "KLDO":Stock("KLDO"), "CAN":Stock("CAN")
                        
                        ,"MNOV": Stock("MNOV"), "BBI":Stock("BBI"), "NKE":Stock("NKE"), "PIC":Stock("PIC"), "SUNW":Stock("SUNW")
                        
                        , "JE":Stock("JE"), "OPTT":Stock("OPTT"), "GME":Stock("GME"), "KTOS":Stock("KTOS")
        }
        
        
        self.counter = 0
        
        # switches for the mods
        self.enableLowVolumeMod = False
        self.enableFallingKnifeMod = False
        self.enableNoFirstRedCandleMod = False

        # holds the start time of the current market day. 
        self.currentMarketStartTime = None
        
        self.MAX_RISK = 0.06

        self.isPrintTrue = False # irrelevant
        
        # investing 1000 dollars for each stock 
        self.cashToInvestPerStock = 1000
            
        self.SetStartDate(2020, 12, 1)  
        self.SetEndDate(2020, 12, 31)  
        self.SetCash(25000)
        self.UniverseSettings.ExtendedMarketHours = True
        
        self.atrDict = {}
        
        for stockName in self.equities:
            
            # stockName and self.equities[stockName].symbol are the same stock's name/symbol
            self.AddEquity(stockName, Resolution.Second, Market.USA, True, 0, True)
            
            #self.Securities[stockName].SetDataNormalizationMode(DataNormalizationMode.Raw);
            
            self.atrDict[stockName] = self.ATR(stockName, 14, MovingAverageType.Simple, Resolution.Daily)
            # zero transaction fees 
            self.Securities[stockName].FeeModel = ConstantFeeModel(0)
            
            # to be used in investigating whether the buy order has been filled
            self.lastOrderEvent = None 
            
            # define our 1 minute trade bar consolidator. we can
            # access the 1 minute bar from the DataConsolidated events
            minuteConsolidator = TradeBarConsolidator(timedelta(minutes=1))
    
            # attach our event handler. the event handler is a function that will
            # be called each time we produce a new consolidated piece of data.
            minuteConsolidator.DataConsolidated += self.OnMinuteCandle
    
            # this call adds our 1 minute consolidator to
            # the manager to receive updates from the engine
            self.SubscriptionManager.AddConsolidator(stockName, minuteConsolidator)
            
            
            
        
            # define our 1 minute trade bar consolidator. we can
            # access the 1 minute bar from the DataConsolidated events
            dailyConsolidator = TradeBarConsolidator(timedelta(days = 1))
    
            # attach our event handler. the event handler is a function that will
            # be called each time we produce a new consolidated piece of data.
            dailyConsolidator.DataConsolidated += self.OnDailyCandle
    
            # this call adds our 1 minute consolidator to
            # the manager to receive updates from the engine
            self.SubscriptionManager.AddConsolidator(stockName, dailyConsolidator)
            
            
            
            # define our 1 minute trade bar consolidator. we can
            # access the 1 minute bar from the DataConsolidated events
            fiveMinuteConsolidator = TradeBarConsolidator(timedelta(minutes = 5))
    
            # attach our event handler. the event handler is a function that will
            # be called each time we produce a new consolidated piece of data.
            fiveMinuteConsolidator.DataConsolidated += self.OnFiveMinuteCandle
    
            # this call adds our 1 minute consolidator to
            # the manager to receive updates from the engine
            self.SubscriptionManager.AddConsolidator(stockName, fiveMinuteConsolidator)
            
            self.tradeBarWindow = RollingWindow[TradeBar](5)
      
        
        self.SetWarmUp(14, Resolution.Daily)
        
    
    
    def OnFiveMinuteCandle(self, sender, bar):
        pass
        '''
        stock = self.equities[str(bar.Symbol)]
        if stock.isMarketOpen and self.isAfter945():
            stock.sumFiveMinBarHeight = stock.sumFiveMinBarHeight + self.getBarHeight(bar)
            timeElapsedInMinutes = (self.Time - stock.buyDecisionMinute).minutes
            averageFiveMinBarHeight = stock.sumFiveMinBarHeight/timeElapsedInMinutes 
        '''
            
    def getBarHeight(self, bar):
        '''
        function description: close - open preferred to high - low 
        '''
        return bar.Close - bar.Open
        
    def OnDailyCandle(self, sender, bar):
        '''stock = self.equities[str(bar.Symbol)]
        if self.Securities[stock.symbol].Exchange.DateTimeIsOpen(self.Time):
        ''' 
        stock = self.equities[str(bar.Symbol)]
        self.atrDict[stock.symbol].Update(bar)
        # check if the indicator is ready
        if self.atrDict[stock.symbol].IsReady:
            atrValue = self.atrDict[stock.symbol].Current.Value
            stock.atr = self.atrDict[stock.symbol].Current.Value 
            self.Debug(atrValue)
            self.Debug("The Above is the ATR Value")
            self.Debug(stock.symbol)
            self.Debug("The Above is the stock the atr val above is for")
            self.Debug(str(self.Time))
            self.Debug("The Above is the TIME")
            
            
    
    def OnData(self, data):
        '''
        function description: Any trading code in here will be at the "second" level (time is in seconds)
        '''
        
        # catch errors from ticker symbols not being found
        try:
        
            for stockName in self.equities:
                
    
                # stock is the Stock object 
                stock = self.equities[str(stockName)]
                
                # if it is the start of a new day or the stock is a falling knife, reset variables in the stock 
                if (self.Time.hour == 4 and self.Time.minute == 0 and self.Time.second == 1) or self.isFallingKnife(stock):
                    self.resetVariables(stock)
                
                # if it's time to buy and the stock.atr/stock.buyPrice is less than 6%, preventing me on risking on any wild stocks 
                if stock.triggerBuyDecisionMinute and self.Time < (stock.postBuyDecisionMinute): #and self.isAfter945(): 
    
                    # send the buy order if you haven't already
                    if stock.isBuyOrderSent == False: 
                        stock.buyTicket = self.LimitOrder(stock.symbol, stock.size, stock.buyPrice) 
                        stock.isBuyOrderSent = True
    
                    
                    # if the buy order is already filled and it's still buy 
                    # decision minute, still can trigger sell() method
                    elif stock.isBuyOrderFilled:
                        self.sell(stock)
                            
                # if the buy order has been sent and not filled, and it's past the 
                # buy decision minute already, cancel 
                elif stock.isBuyOrderSent and stock.isBuyOrderFilled == False and self.Time >= (stock.postBuyDecisionMinute) and stock.isBuyOrderCancelled == False:
                    
                    # catch errors regarding cancelling orders that have already been executed
                    try:
                        cancelBuyOrder = stock.buyTicket.Cancel()
                        stock.isBuyOrderCancelled = True
                    except:
                        pass
         
                # if the buy order is already filled, trigger sell() method
                else:
                    if stock.isBuyOrderFilled:
                        self.sell(stock)        
        except:
            self.Debug("=========")
            self.Debug(stock.symbol)
            self.Debug("Okay probably the above stock isn't in database")
            self.Debug("=========")
            
    def sell(self, stock):
        ''' 
        function description: adjusts the sell order according to the price
        '''
        
        # catch errors regarding cancelling orders that have already been executed
        try:
            # check if the stock has already been sold
            if self.isStockSold(stock):
                self.Debug(stock.symbol)
                self.Debug("Stock has been sold, now resetting all vars")
                # then reset all variables 
                self.resetVariables(stock)
            
            # since the stock has not yet been sold ... 
            else:
              
                # if the price has dipped more than or equal to 6%, prep the sellForLoss order
                stock.maxRisk = stock.atr/stock.buyPrice
                if (self.Securities[stock.symbol].Price - stock.buyPrice)/stock.buyPrice <= -(stock.maxRisk + 0.001):
    
                    if stock.isSellForWinOrderSent and stock.isSellForLossOrderSent == False:
                        cancelSellForWinOrder = stock.sellForWinTicket.Cancel()
                        combinedString = "LOSS " + str(stock.atr*100/stock.buyPrice)
                        # send the sell for loss order
                        stock.sellForLossTicket = self.LimitOrder(stock.symbol, -(stock.size), self.Securities[stock.symbol].Price, combinedString)
                        stock.isSellForLossOrderSent = True
                        stock.isSellForWinOrderSent = False
          
                    elif stock.isSellForWinOrderSent == False and stock.isSellForLossOrderSent == False:
                        combinedString = "LOSS " + str(stock.atr*100/stock.buyPrice)
                        stock.sellForLossTicket = self.LimitOrder(stock.symbol, -(stock.size), self.Securities[stock.symbol].Price, combinedString)
                        stock.isSellForLossOrderSent = True
                    
                # else, the price is not low enough to warrant sending a sell for loss order
                # i can prep the sellForWin order here
                else:
                    
                    # if the sell for loss order has been sent already, cancel the 
                    # sell for loss order first 
                    if stock.isSellForLossOrderSent and stock.isSellForWinOrderSent == False:
                        combinedString = "WIN " + str(stock.atr*100/stock.buyPrice)
                        cancelSellForLossOrder = stock.sellForLossTicket.Cancel()
                        stock.sellForWinTicket = self.LimitOrder(stock.symbol, -(stock.size), stock.sellForWinPrice, combinedString)
                        stock.isSellForLossOrderSent = False
                        stock.isSellForWinOrderSent = True 
                        
                    # elif just send the sell for win, if it hasn't been sent already    
                    elif stock.isSellForLossOrderSent == False and stock.isSellForWinOrderSent == False:
                        combinedString = "WIN " + str(stock.atr*100/stock.buyPrice)
                        stock.sellForWinTicket = self.LimitOrder(stock.symbol, -(stock.size), stock.sellForWinPrice, combinedString)
                        stock.isSellForWinOrderSent = True
                    
        except:
            pass
    

    def isFallingKnife(self, stock):
        '''
        function description: if the stock falls >=0.6% before I even start trading when the 
        market is open, returns True
        '''
        if stock.triggerBuyDecisionMinute == False and stock.isMarketOpen:# and self.isAfter1130():
            if self.Securities[stock.symbol].High > stock.maxPriceBeforeTrading :
                stock.maxPriceBeforeTrading = self.Securities[stock.symbol].High
            
            if self.Securities[stock.symbol].Low < stock.minPriceBeforeTrading:
                stock.minPriceBeforeTrading = self.Securities[stock.symbol].Low
            
            if (1 - stock.minPriceBeforeTrading/stock.maxPriceBeforeTrading) >= self.MAX_RISK:
                self.Debug("This is a falling knife")
                return True 
            else:
                return False
                
    def isAfter945(self):
        if self.Time.hour > 9 or self.Time.hour < 4:
            if self.Time.hour == 9:
                if self.Time.minute > 45:
                    return True
                else:
                    return False
            else:
                return True    
        else:
            return False
        
    def isLowVolume(self, bar, stock):
        '''
        function description: returns True if the average volume 
        of the stock before I trade it is < 5000
        '''
        if stock.triggerBuyDecisionMinute == False and stock.isMarketOpen and self.enableLowVolumeMod:
            stock.totalVolumeBeforeTrading = stock.totalVolumeBeforeTrading + bar.Volume
            numberMinutesElapsed = (self.Time - self.currentMarketStartTime).total_seconds()/60
            
            # check that average volume per minute candle is < 5000
            if stock.totalVolumeBeforeTrading/numberMinutesElapsed < 5000:
                return True 
            else:
                return False

    
    def OnMinuteCandle(self, sender, bar):
        '''
        function description: any trading code in here will be at the minute level
        '''
        
        # stock is the Stock object
        stock = self.equities[str(bar.Symbol)]
        
        
        # update the indicator value with the new input close price every day

        
        try:
            if self.isLowVolume(bar, stock) == False:
                self.Debug("Stock is too high volume")
                self.resetVariables(stock)
            
            self.printMinuteCandleOHLC(bar)
            
            # decide to open the market for the stock or not
            self.decideIfMarketShouldBeSetOpen(bar, stock)
            
            if stock.isMarketOpen == False: 
                self.getPremarketLow(bar, stock)
              
            elif stock.isMarketOpen:
                self.findPreTradingConditions(bar, stock)
                # if it is the start of a new day or the stock is a falling knife, reset variables in the stock 
        except:
            pass
            
    
    def getPremarketLow(self, bar, stock):
        if bar.Low < stock.premarketLow:
            stock.premarketLow = bar.Low
    
    def isFirstOneMinCandleRed(self, bar, stock):
        if bar.Time.hour == 9 and bar.Time.minute == 30 and bar.Close < bar.Open and self.enableNoFirstRedCandleMod:
            return True 
        else:
            return False
            
    def decideIfMarketShouldBeSetOpen(self, bar, stock):
        '''
        function description: decides if the stock.isMarketOpen should be set to true
        stock.isMarketOpen will not be set to true if it is a multiple day play.
        market will only be considered open from 9.31 onwards, since in the OnMinuteCandle function, we want to start
        reading only from the 9.30 candle onwards.
        '''
        if (self.Time.hour == 9 and self.Time.minute == 31): #and self.isFirstOneMinCandleRed(bar, stock):
            if stock.isMultipleDayPlay == False:
                stock.isMarketOpen = True
                
                # save the 9.30AM time 
                self.currentMarketStartTime = self.Time - timedelta(minutes = 1)

   
    def findPreTradingConditions(self, bar, stock):
        ''' 
        function description: finds the conditions necessary to execute the trading process
        '''
        
        
        # Finds when the premarketLow has been broken.
        if bar.Low < stock.premarketLow and stock.isAfterPremarketLowCracked == False:
            stock.isAfterPremarketLowCracked = True
            stock.premarketCrackedTime = self.Time - timedelta(minutes = 1)
        
        # if there is a redsprout, set the trading variables
        elif stock.isAfterPremarketLowCracked and stock.isAfterRedSprout == False:
            if bar.High > stock.premarketLow:
                if bar.Close < bar.Open:
                    self.setTradingVariables(bar, stock)
                    
    
    def setTradingVariables(self, bar, stock):
        ''' 
        function description: sets variables relevant to the buy decision minute
        and activates the OnData function.
        '''
        stock.buyPrice = bar.Low

        stock.sellForWinPrice = bar.High

        stock.sellForLossPrice = stock.buyPrice * 0.94
        stock.isAfterRedSprout = True
        stock.buyDecisionMinute = self.Time  
        stock.postBuyDecisionMinute = self.Time + timedelta(minutes = 1)
        stock.triggerBuyDecisionMinute = True  
        
        # decide the size
        stock.size = int(self.cashToInvestPerStock/stock.buyPrice)
    
    
    def isStockSold(self, stock):
        '''
        function descriptions: checks if the stock has been successfully sold
        '''
        # catch errors from ticker symbols not being found
        try:
            if stock.isBuyOrderFilled and self.Portfolio[stock.symbol].Invested == False:
                return True 
        except:
            pass
     
    def OnOrderEvent(self, orderEvent):
        '''
        function description: finds whether the buy order is filled 
        '''
        try:
            for stockName in self.equities:
                
                # stock is the Stock object
                stock = self.equities[stockName]
                
                # check if the stock exists in the portfolio, that means it has been bought already
                # it must also not be a multiple day play for that stock, since I don't want the stock
                # to be bought again accidentally on the second day
                if self.Portfolio[stock.symbol].Invested and stock.isMultipleDayPlay == False:
                    self.lastOrderEvent = orderEvent
                    stock.isBuyOrderFilled = True
                    self.Debug(str(self.Time))
                    self.Debug("The time above is when isBuyOrderFilled is set to True")
        except:
            pass
            
    def printMinuteCandleOHLC(self, bar):
        '''
        function description: prints out the Open High Low and Close for a candle at a specified time 
        in bar.Time.hour and bar.Time.minute below give the EXACT hour and minute for the
        minute candle you wish to investigate.
        '''
        if bar.Time.hour == 10 and bar.Time.minute == 5:
            self.Debug(str(bar.Time))
            self.Debug("The Above is the exact timeBar the OHLC refers to ")
            self.Debug(bar.Open)
            self.Debug("Above is the Open")
            self.Debug(bar.High)
            self.Debug("Above is the High")
            self.Debug(bar.Low)
            self.Debug("Above is the Low")
            self.Debug(bar.Close)
            self.Debug("Above is the Close")
 
    def askIsMultipleDayPlay(self, stock):
        '''
        function description: if the stock is not sold on the first day, this function
        ensures some variables are not reset, allowing the stock to be held over the following days,
        via the isMultipleDayPlay boolean flag
        ''' 
      
        if self.Portfolio[stock.symbol].Invested:
            stock.isMultipleDayPlay = True
        else:
            stock.isMultipleDayPlay = False
            
    
        
            
    def resetVariables(self, stock):
        '''
        function description: resets all variables of the stock object if it is the end of the day
        if it is a multiple day play, no variables are reset
        '''
        self.askIsMultipleDayPlay(stock)
        if stock.isMultipleDayPlay == False:
            stock.isMarketOpen = False
            stock.sumFiveMinBarHeight = 0 
            stock.maxPriceBeforeTrading = 0
            stock.minPriceBeforeTrading = 300000
            stock.totalVolumeBeforeTrading = 0
            stock.maxRisk = 0
            stock.premarketLow = 300000
            stock.premarketCrackedTime = None
            stock.isAfterPremarketLowCracked = False 
            stock.isAfterRedSprout = False
            stock.buyPrice = 0
            stock.sellForWinPrice = 0 
            stock.sellForLossPrice = 0 # irrelevant 
            stock.buyDecisionMinute = None
            stock.buyTicket = None
            stock.sellForWinTicket = None
            stock.sellForLossTicket = None
            stock.isBuyOrderSent = False
            stock.isBuyOrderFilled = False
            stock.isAnySellOrderSent = False
            stock.isSellForWinOrderSent = False
            stock.isSellForLossOrderSent = False
            stock.triggerBuyDecisionMinute = False
            stock.size = 0
            stock.isBuyOrderCancelled = False
            self.Debug("All the stock variables are being reset")
        else:
            self.Debug(str(self.Time))
            self.Debug("This is a Multiple Day Play, none of the stock object variables are being reset")  
    
    

class Stock:
    def __init__(self,symbol):
        self.symbol = symbol
        
        self.maxPriceBeforeTrading = 0
        self.minPriceBeforeTrading = 300000
        self.totalVolumeBeforeTrading = 0
        
        # do not reset the atr
        self.atr = 0 
        
        self.sumFiveMinBarHeight = 0 

        self.maxRisk = 0
        self.isMarketOpen = False
        self.premarketLow = 300000
        self.premarketCrackedTime = None
        self.isAfterPremarketLowCracked = False 
        self.isAfterRedSprout = False
        self.buyPrice = 0
        self.sellForWinPrice = 0 
        self.sellForLossPrice = 0 # irrelevant 
        self.buyDecisionMinute = None
        self.postBuyDecisionMinute = None
        self.buyTicket = None
        self.sellForWinTicket = None
        self.sellForLossTicket = None
        self.isBuyOrderSent = False
        self.isBuyOrderFilled = False
        self.isAnySellOrderSent = False
        self.isSellForWinOrderSent = False
        self.isSellForLossOrderSent = False
        self.ishelp = False
        self.size = 0
        self.triggerBuyDecisionMinute = False
        self.isBuyOrderCancelled = False
        
        # used to decide if the play should extend over multiple days 
        self.isMultipleDayPlay = False
        # end of variables setting
